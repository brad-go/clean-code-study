# 동시성

> “Objects are abstractions of processing. Threads are abstractions of schedule.”
- Jmaes O. Coplien
> 

## 동시성이 필요한 이유?

---

- 동시성은 결합을 없애는 전략이다.
- 무엇과 언제를 분리하는 전력이다.
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
- 웹 애플리케이션이 표준으로 사용하는 서블릿 모델
    - 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다.
    - 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.
- 단인 스레드 수집기는  웹 소켓에서 입출력을 기다리는 시간이 아주 많다. 한 번에 한 사이트를 방문하는 대신 다중 스레드 알고리즘을 이용하면 수집기 성능을 높일 수 있다.

### 미신과 오해

- 동시성은 다소 부하를 유발한다,.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 제한하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.
- 동시성은 때로 성능을 높여준다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.

## 난관

---

```java
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}

public static void main(String args[]) {
    final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(42);
    
    Runnable runnable = new Runnable() {
        public void run() {
            classWithThreadingProblem.getNextId();
        }
    };
    
    Thread t1 = new Thread(runnable);
    Thread t2 = new Thread(runnable);
    t1.start();
    t2.start();
}
```

- t1이 43을, t2가 44를 가져간다. lastIdUsed는 44이다.(O)
- t1이 44을, t2가 43를 가져간다. lastIdUsed는 44이다.(O)
- t1이 43을, t2가 43를 가져간다. lastIdUsed는 43이다.(X)

## 동시성 방어 원칙

---

- ****단일 책임 원칙(Single Responsibility Principle, SRP)****
    - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
    - 동시성 코드에는 독자적인 난관이 있다.
    - 잘못 작성된 동시성 코든느 여러 문제를 발생시킬 수 있고, 추가적인 코드 없이 해결되기는 어렵다.
    
    → 동시성 코드는 다른 코드와 분리하라.
    

- **따름 정리 : 자료 범위를 제한하라.**
    - 한 두군데를 보호하는 것을 까먹기 쉬우며 이로 인해 해당 자원을 수정하는 모든 코드를 망가트리게 된다.
    - 모든 곳이 보호되었는지 파악하기 위해 중복적인 노력이 필요하게 된다.
    - 이미 찾기 어려운 문제의 근원을 더 찾기 어렵게 만들게 된다.
    
    → 데이터 캡슐화 하고 공유 자료를 최대한 줄인다.
    

- **따름 정리 : 자료 사본을 사용하라**
    - 공유 자원 문제를 해결하는 좋은 방법중 하나는 애초에 공유 자원을 사용하지 않는 것
    - 읽기 전용으로 사용될 경우 자원의 복사본을 사용하게 하는 방법이 있다.
    - 복사본을 여러 스레드에 전달, 작업을 수행하고 결과를 단일 스레드에서 수집해 사용하는 것도 가능

- **따름 정리 : 스레드는 가능한 독립적으로 구현하라.**
    - 스레드 코드를 공유 자원을 사용하지 않는 독립된 세계로 만든다면 동기화 문제는 없어지게 된다.
    - HttpServlet을 생각해 보라. HttpServlet을 상속받는 클래스는 doGet, doPost와 같은 메서드에서 필요한 파라미터를 받아 처리
        - Servlet이 각자의 세계에 있는 것처럼 작동하게 도와주며, 지역 변수를 사용하는 한 동기화 문제는 발생하지 않게 된다.
    
    → 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하자
    

## 라이브러리를 이해하라

---

- 자바에서 제공하는 thread-safe 컬랙션을 사용하라.
- 연관이 없는 태스크들을 수행시 executor 프레임워크를 사용하라.
- 가능하면 nonblocking 방법을 사용하라.
- 몇몇 라이브러리 클래스들은 thread-safe하지 않다.

### 스레드 환경에 안전한 컬렉션

[ava.util.concurrent 패키지](https://www.notion.so/76164429ab5e4dd29e831cc7b3a17af0)

→ 언어가 제공하는 클래스를 검토하자.

## 실행 모델을 이해하라

---

[기본 용어](https://www.notion.so/d9f587ce86a647df974aced78a69cad5)

### 생산자 - 소비자

- 한 개 이상의 생산자가 생산한 작업물을 버퍼 혹은 큐에 넣는다.
- 한 개 이상의 소비자가 버퍼 혹은 큐에서 작업물을 습득, 작업을 마친다.
- 생산자와 소비자 사이에 있는 큐는 한정된 자원이다. 따라서 생산자는 큐에 남는 공간이 생길 때까지, 소비자는 큐에 작업물이 하나라도 생길 때까지 기다려야 한다.
- 큐를 통한 생산자와 소비자간의 조율에는 둘 사이의 시그널링이 필요하다.
- 생산자는 큐에 작업물을 넣고 소비자에게 "큐가 비어있지 않다"는 신호를 보내고 소비자는 큐에서 작업물을 꺼낸 후 "큐가 가득차 있지 않다"는 신호를 보낸다.
- 그 전까지 둘은 신호를 기다린다.

### 읽기-쓰기

- 일반적으로 독자를 위한 정보로 사용되며, 가끔 저자에 의해 업데이트되는 공유 자원의 경우 처리량이 문제가 된다.
- 처리량을 강조해 독자가 상대적인 우선권을 가지게 되면 저자는 기아 상태에 빠지며 공유 자원은 정체된 정보로 가득차게 된다.
- 반대로 저자가 우선권을 가지면 처리량이 줄어들게 된다.
- 저자-독자 문제는 이 둘 사이의 균형을 맞추며 concurrent 업데이트를 방지하는 것을 주안점으로 둔다.

### 식사하는 철학자들

- 원탁을 둘러싼 여러 명의 철학자들이 있다.
- 각 철학자의 왼쪽에 포크가 놓여 있으며 테이블의 중앙에 큰 스파게티 한 그릇이 놓여 있다.
- 그들은 배가 고파지기 전까지 각자 생각을 하며 시간을 보낸다.
- 배가 고파지면 그들은 자신의 양쪽에 놓여 있는 포크 2개를 잡고 스파게티를 먹는다.
- 철학자는 포크 2개가 있어야만 스파게티를 먹을 수 있다.
- 그렇지 않다면 옆 사람이 포크를 다 사용하기 전까지 기다려야 한다. 스파게티를 먹은 철학자는 다시 배가 고파질 때까지 포크를 놓고 있게 된다.
- 철학자를 스레드로, 포크를 공유 자원으로 바꾸게 되면 이는 자원을 놓고 경쟁하는 프로세스와 비슷한 상황이 된다. 잘 설계되지 않은 시스템은 deadlock, livelock, 처리량 문제, 효율성 저하 문제에 맞닥뜨리기 쉽다.

당신이 맞닥뜨릴 대부분의 concurrent관련 문제들은 이 세 가지 문제의 변형일 가능성이 높다. 이 알고리즘들을 공부하고 스스로 해법을 작성함으로써 이와 같은 문제들을 직면하더라도 의연하게 대처할 수 있도록 하자.

→ 위 3가지의 기본 알고리즘과 각 해법을 이해한다.

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

---

- 동기화된 메서드 간의 의존성은 동시성 코드에서 사소한 버그를 일으킬 수 있다.
- 자바는 synchronized라는 "메서드 하나를 보호하는 노테이션"을 제공한다.
- 한 클래스에 두 개 이상의 synchronized 메서드가 존재하면 문제를 일으킬 수도 있다.

→ 공유 객체 하나에는 메서드 하나만 사용하자.

1. 클라이언트 기반 잠금 : 클라이언트가 첫 메서드를 부르기 이전부터 마지막 메서드를 부른 다음까지 서버를 잠근다.
2. 서버 기반 잠금 : 서버 내에서 서버(자신)을 잠그고 모든 동작을 수행한 후 잠금을 푸는 메서드를 제공한다. 클라이언트에게는 새로운 메서드를 제공한다.
3. 중계된 서버 : 잠금을 수행하는 중계자를 작성한다. 이는 기본적으로 서버 기반 잠금이지만 기존의 서버를 변경할 수 없는 상황에 사용할 수 있는 방법이다.

## 동기화 하는 부분을 작게 만들어라

---

Synchronized로 수행되는 잠금은 딜레이와 오버헤드를 만들기 때문에 "비싼 수행"으로 간주되며 가능한 한 작게 만들어야 한다. 반면 임계영역(critical section)은 꼭 보호되어야 한다.

→ 동기화하는 부분을 최대한 작게 만들자.

## 올바른 종료 코드는 구현하기 어렵다

---

- 항상 살아 있어야 하는 코드의 작성은 잠시 동작하고 조용히 끝나는 코드의 작성과는 다르다.
- 조용히 끝나는 코드는 작성하기 어렵다. 이는 보편적으로 오지 않을 신호를 기다리는 쓰레드의 데드락을 포함한다.
- 데드락에 걸린 자식 스레드의 수행이 끝나길 기다리는 부모 스레드의 경우를 생각해 보라. 자식은 데드락에 걸려 멈춰 있고 부모는 이를 끝없이 기다리게 된다.
- 이와 같은 코드를 작성할 경우 정상적인 종료가 이루어질 때까지 많은 시간이 소요될 것을 상정해야 한다.

→ 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현한다. 

## 스레드 코드 테스트하기

---

- 테스트는 정확성을 보장하지 않으며 "코드가 제대로 작성되었는가"를 증명할 수 없다.
- 다만 잘 작성된 테스트는 위험을 최소화할 수 있다.
- 이는 멀티 스레드 상황에서는 훨씬 더 복잡해 진다.

→ 문제를 노툴하는 테스트 케이슬르 작성한다. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌린다. 다시 돌렸더니 통과하더라는 이유는 안된다.

### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라

- 멀티 스레드 코드는 일반적으로 발생할 리 없어 보이는 문제를 발생시킨다.
- 대부분의 개발자는 이러한 문제를 직관적으로 파악하지 못한다.
- 그래서 개발자들은 이러한 문제들을 우주선(宇宙線), 하드웨어 버그, 혹은 이러한 류의 일회성으로 치부한다.
- 이러한 일회성들이 무시될 수록 더 많은 코드들이 이미 문제가 있는 시스템에 추가되게 될 뿐이다.

→ 시스템 실패를 일회성이라 치부하지 마라.

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

- 스레드 밖에서 잘 동작하는 코드를 먼저 작성하라.
- 시스템은 가능한 한 POJO로 작성하는 것이 좋다.

→ 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅 하지 않는다.

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라

- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
- 스레드 코드를 실제 환경이나 테스트 환경에서 둘러본다.
- 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
- 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

→  다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

- 스레드 관련 코드의 적절한 균형을 맞추는 작업은 보통 시행착오를 필요로 한다.
- 여러 환경에서 시스템의 퍼포먼스를 테스트할 수 있는 방법을 개발 초기에 강구하라.
- 실행할 스레드 갯수를 쉽게 변경할 수 있게 작성하라.
- 이를 시스템이 동작하는 도중에 변경할 수 있게 하는 것을 고려해 보라.
- 처리량과 시스템 활용도를 기준으로 스스로를 조정할 수 있게 하는 것을 고려해 보라.

### 프로세서 수보다 많은 스레드를 돌려보라

- 시스템이 작업을 전환할 때에도 문제는 발생한다.
- 작업 전환을 빈번히 발생하게 하기 위해 프로세서 수보다 많은 스레드를 실행해 보라.
- 작업 전환이 잦을수록 빠뜨린 critical section이나 dead lock을 찾을 확률이 높아지게 된다.

### 다른 플랫폼에서 돌려보라

- 서로 다른 운영체제는 상이한 스레딩 정책을 가지며 코드의 실행에 영향을 미친다.
- 멀티 스레드 코드는 실행 환경에 따라 다르게 동작한다. 따라서 당신은 모든 잠재적 배포 환경에 대해 테스트를 수행해야 한다.

→ 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라.

### 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라

- 스레드 관련 문제는 수많은 실행 경로중 얼마 안되는 확률로 발생하기 때문에 드물게 발생하며 재현하기 어렵다.
- 이 실행 경로를 조작해 스레드 문제가 발생할 확률을 높이는 code instrumentation에는 두 가지 방법이 있다.
    1. 직접 구현하기
        
        ```java
        //Object.wait(), Object.sleep(), Object.yield(), Object.priority()등의
        //메서드를 사용해 실행 경로를 변경함으로써 코드의 문제를 발견
        public synchronized String nextUrlOrNull() {
            if(hasNext()) {
                String url = urlGenerator.next();
                Thread.yield();
                // inserted for testing.
                updateHasNext();
                return url;
            }
            return null;
        }
        ```
        
        - 테스트할 부분을 직접 찾아야 한다.
        - 어디에 어느 메서드를 호출해야 할지 알기 어렵다.
        - 이와 같은 코드를 제품에 포함해 배포하는 것은 불필요하게 퍼포먼스를 저하시킬 뿐이다.
        - Shotgun approach이기 때문에 반드시 문제가 발생한다는 보장을 얻을 수 없다.
        - 시스템을 최대한 POJO 단위로 나눠 instrument code를 삽입할 부분을 찾기 쉽게 하고 여러 정책에 따라 sleep, yield등을 삽입할 수 있게 해야 한다.
    2. 자동화
        
        ```java
        //Aspect-oriented Framework, CGLib, ASM등을 통해 프로그램적으로 코드를 조작
        public class ThreadJigglePoint {
            public static void jiggle() { }
        }
        
        public synchronized String nextUrlOrNull() {
            if(hasNext()) {
                ThreadJiglePoint.jiggle();
                String url = urlGenerator.next();
                ThreadJiglePoint.jiggle();
                updateHasNext();
                ThreadJiglePoint.jiggle();
                return url;
            }
            return null;
        }
        ```
        
        - '아무 것도 안하기', 'sleep', 'yield'등을 무작위로 선택하게 할 수 있다.

## 결론

---

동시성 코드를 작성하게 된다면 엄격한 기준으로 클린하게 작성한다.

최우선적으로 SRP를 숙지하라. 시스템을 최대한 POJO단위로 잘라 스레드 관련 코드와 非 스레드 관련 코드를 나누어라. 스레드 관련 코드를 테스트할 때에는 그 이외의 것들은 제외하고 스레드 관련 문제만 테스트하라. 이는 스레드 관련 문제가 최대한 작은 부분에 집중되게 한다.

한 공유 자원에 대한 멀티 스레드 수행, 공유되는 자원 풀 등 concurrency 문제를 일으킬 수 있는 부분에 대해 인지하라. 깔끔하게 종료되게 하는 문제나 반복문 탈출과 같은 문제는 특히 성가실 수 있다.

라이브러리를 이해하고 기본적인 알고리즘을 이해하라. 라이브러리가 제공하는 기능이 어떻게 문제를 해결하는지 이해하라.

잠가야 할 필요가 있는 부분을 찾는 방법을 배우고 잠가라. 쓸데 없는 구간을 잠그지 마라. 잠긴 구간에서 또 다른 잠긴 구간을 부르는 것을 기피하라.

문제는 돌연 발생할 것이다. 그렇지 않은 문제들은 보통 "한번만 발생하는" 문제로 치부된다. 이러한 일회성들은 보통 시스템에 부하가 걸린 경우, 혹은 무작위로 발생한다. 그러므로 스레드 관련 코드는 여러 설정, 환경에서 반복적이고 지속적으로 수행해 보라.

시간을 들여 보조 코드를 추가하면 오류가 드러날 가능성이 크게 높아진다. 초반부터 보조 코드를 고려한다.

깔끔한 접근 방식을 취한다면 코드가 올바르게 돌아갈 가능성이 극적으로 높아진다.

## Quiz

---

- 객체는 처리의 추상화다. 스레드는 00의 추상화다.  00는?
    - 일정
- 동시성 코드를 작성할 때 최우선적으로 숙지하라고한 원칙은?
    - SRP